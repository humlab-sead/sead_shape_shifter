---
**⚠️ NOTE:** This document contains original design notes and has been superseded by structured design documentation:

- **Start here:** [README.md](./README.md) - Overview and navigation guide
- **Identity System:** [SEAD_IDENTITY_SYSTEM.md](./SEAD_IDENTITY_SYSTEM.md) - Hybrid Integer + UUID architecture (external to Shape Shifter)
- **Ingester Design:** [SEAD_INGESTER_DESIGN.md](./SEAD_INGESTER_DESIGN.md) - Complete ingester component specification

This file is kept for historical reference and context.

---

# Original Design Notes: New SEAD Ingester

TODO: New SEAD ingester

You and I will design a new ingester that creates SQL DML code instead of writing data to files on disk.

I need your opinion on how to design a ingester that creates SQL DML code instead of writing data to files on disk. My vision is that this system not only is used for reconciliation of data to existing entities in the remote system (e.g. SEAD), but also using using n API published by the SEAD system can allocate primary keys for new entities, and resolve FKs now referring to systems ids to  allocated SEAD of. SEAD uses "Sqitch" as the database change control system, so ultimatly the dispatch should create a SQL DML ready to be commited into SEAD.

The current workflow is this:

  Data provider's data                --> Shape Shifter [ USER ]              --> Project YAML
  Data provider's data + Project YAML --> Shape Shifter [ NORMALIZER ]        --> Normalized DataFrames 
  Normalized DataFrames               --> Shape Shifter [ DISPATCHER ]        --> SEAD-conforming Data (csv or Excel)
  SEAD-conforming Data                --> Shape Shifter [ INGESTER ]          --> SEAD Clearinghouse Submission
  SEAD Clearinghouse Submission       --> SEAD Transport System               --> SEAD Change Request (SQL DML scripts)
  SEAD SEAD Change Request            --> SEAD Change Control System (Sqitch) --> SEAD database
  
Ideally, the same Project YAML can be used for future ingestions, but each new dataset will require some manual, computer-assisted work for e.g. a reconciliation step to match the new data to existing SEAD entities, or for specifying mandatory data that is missing in the incoming data.

Currently, there is no capability to allocate new SEAD ids for new entities. This is done by the SEAD Transport systen that receives the SEAD-conforming data from the dispatcher, and creates a change request with SQL DML scripts that includes allocation of new SEAD ids. This is a bottleneck in the workflow, and it would be great if the dispatcher could handle this instead, by calling an API published by the SEAD system that can allocate new SEAD ids for new entities, and resolve FKs now referring to systems ids to allocated SEAD ids. This would allow for a more streamlined workflow.

The first problem we need to resolve is designing a robust and safe system for allocating new identities in SEAD. This is a critical part of the workflow, and we need to ensure that it is done in a way that does not cause conflicts or inconsistencies in the SEAD database.

SEAD identities are currently generated by the PostgreSQL database using sequences. All primary keys in SEAD are integers, and they are generated by sequences that are defined in the database. This is a crucial detail that we need to take into account when designing the identity allocation system.

The integer system ids have historically been a big problem, since relying on them being stable across different runs of the system is very brittle. The system ids are used as target columns for FKs, and if the system ids change, the FK relationships will break. This is a problem that we need to solve in a robust way. We don't have a safe wway today to keep system ids stable across different runs of the system. We need to design a system that can allocate new SEAD ids for new entities in a way that is robust and does not cause conflicts or inconsistencies in the SEAD database. Possibly we must remove the reliance on sequence-generated integer system ids, and instead use a more robust and stable identifier system, such as UUIDs. This would allow us to allocate new SEAD ids for new entities in a way that is robust and does not cause conflicts or inconsistencies in the SEAD database.

Phase 1 for us is to design a system for allocating new SEAD ids for new entities. These SQL DDL/DML scripts is used today to allocate and store SEAD ids, pertaining the mappings between system ids and SEAD ids. 

```sql


    create table if not exists sead_utility.system_id_allocations (
        uuid UUID not null default uuid_generate_v4() primary key,
        table_name text not null,
        column_name text not null,
        submission_identifier text not null,
        change_request_identifier text not null,
        external_system_id text null,
        external_data JSON null,
        alloc_system_id int not null
    );

    call sead_utility.drop_udf('sead_utility', 'get_next_system_id');
    -- select sead_utility.get_next_system_id('tbl_sites', 'site_id') 
    create or replace function sead_utility.get_next_system_id(p_table_name text, p_column_name text) 
    /*
    * Get the next SEAD system id for table "p_table_name" and column "p_column_name".
    * The system id is allocated from the sead_utility.system_id_allocations table.
    * If no system id has been allocated for the table and column, the function will return the maximum value of the column in the table.
    */
        returns integer as $udf$
        declare
            v_next_id integer;
            v_query text;
        begin
            v_query := format('select max(%s) from %s', quote_ident(p_column_name), quote_ident(p_table_name));
            -- raise notice '%', v_query;
            execute v_query into v_next_id;

            select max(system_id) into v_next_id
            from (
                select coalesce(max(alloc_system_id), 0) as system_id
                from sead_utility.system_id_allocations
                where table_name = p_table_name
                and column_name = p_column_name
                union all
                values (v_next_id)
            );
            return v_next_id + 1;
        end;
        $udf$ language plpgsql;

	call sead_utility.drop_udf('sead_utility', 'allocate_system_id');
	
    create or replace function sead_utility.allocate_system_id(
        p_submission_identifier text,
        p_change_request_identifier text,
        p_table_name text,
        p_column_name text,
        p_system_id text = NULL,
        p_data jsonb = NULL
    ) returns integer as $udf$
        declare 
            v_next_id int;
        begin

            v_next_id = sead_utility.get_next_system_id(p_table_name, p_column_name);
            insert into sead_utility.system_id_allocations (
                table_name,
                column_name,
                submission_identifier,
                change_request_identifier,
                external_system_id,
                external_data,
                alloc_system_id
            ) values (
                p_table_name,
                p_column_name,
                p_submission_identifier,
                p_change_request_identifier,
                p_system_id,
                p_data,
                v_next_id
            );
            return v_next_id;
        end;
        $udf$ language plpgsql;

    create or replace function sead_utility.release_allocated_ids(
        p_submission_identifier text,
        p_change_request_identifier text=null,
        p_table_name text=null,
        p_column_name text=null
    ) 
        returns void as $udf$
        begin
            delete from sead_utility.system_id_allocations
            where submission_identifier = p_submission_identifier   
              and (p_change_request_identifier is null or change_request_identifier = p_change_request_identifier)
              and (p_table_name is null or table_name = p_table_name)
              and (p_column_name is null or column_name = p_column_name)
            ;
        end;
        $udf$ language plpgsql;

    create or replace function sead_utility.get_allocated_id(
        p_submission_identifier text,
        p_change_request_identifier text,
        p_table_name text,
        p_column_name text,
        p_system_id text = NULL
    ) 
        returns integer as $udf$
        declare
            v_alloc_system_id integer;
        begin

            select max(alloc_system_id::int)
                into v_alloc_system_id
                    from sead_utility.system_id_allocations
                    where submission_identifier = p_submission_identifier
                    and change_request_identifier = p_change_request_identifier
                    and table_name = p_table_name
                    and column_name = p_column_name
                    and external_system_id = p_system_id
            ;
            return v_alloc_system_id;
        end;
        $udf$ language plpgsql;
```

Please update SEAD_IDENTITY_SYSTEM according to this:

We need to add use of natural/business keys into the design. Not all data provider's has the capability to deliver UUIDs. We need to be able to uniquely identify entities in the orginating system, UUID or business keys.
Try to take into account that we in the future will need change detection. This will happen when data provider delivers changed data that we need to update in the SEAD database. We might at either require the incoming data to contain update flags, or add some kinf of generically computer SHA on serialized data. - - . Put implementation details such as proposed Database Schema in a separate document. Let us focus on requirements and design in this document.
Keep the document concise, focused and DRY.
To somewhat simplify and allow for easier future update capabiliies we should consider more clearly specifying what entities in the SEAD database are aggregates, and focus on assigning identities and keeping SEAD id <--> UUID/Natural keys mappings for these those.
Please put non-functional requirements and security concearns in a spearate document. This includes audit, performance, testing strategies etc.