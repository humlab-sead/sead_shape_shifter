# SEAD Identity System - Design Document

**Version:** 2.0  
**Date:** February 21, 2026  
**Status:** Design Phase  
**Scope:** SEAD Database System (External to Shape Shifter)

---

## Executive Summary

This document defines a hybrid identity system for SEAD that supports stable external identifiers alongside traditional integer primary keys. External systems can reference SEAD entities using either **UUIDs** (when technically capable) or **natural/business keys** (for legacy systems), enabling distributed data preparation, idempotent ingestion, and future change detection.

**Key Innovation:** External identifiers (UUID or natural key) are mapped to SEAD integer PKs at allocation time, creating a permanent bidirectional mapping. Same external ID → Same SEAD integer (idempotent). This enables systems to work offline, prepare data concurrently, and detect changes in future submissions.

**Supporting Documents:**
- [SEAD_IDENTITY_IMPLEMENTATION.md](./SEAD_IDENTITY_IMPLEMENTATION.md) - Database schema, API specification, SQL functions
- [SEAD_IDENTITY_NFR.md](./SEAD_IDENTITY_NFR.md) - Non-functional requirements, performance, security, testing

---

## Problem Statement

### Current State

SEAD uses PostgreSQL sequence-generated integer primary keys. IDs are assigned at INSERT time, after data reaches the database. This creates several challenges:

1. **Late Binding:** External systems cannot predict IDs before submission
2. **No External References:** Without stable external identifiers, deduplication and reconciliation are error-prone
3. **Sequential Submission:** Multiple data providers cannot work concurrently without ID conflicts
4. **No Change Detection:** Re-submitting updated data creates duplicates instead of updates
5. **Brittle Integration:** External systems track transient internal IDs that change between runs

### Required Capabilities

1. **External Identification:** Data providers must reference entities consistently across submissions
2. **Flexible Identity:** Support both UUIDs (modern systems) and natural keys (legacy providers)
3. **Idempotent Ingestion:** Same external ID → Same SEAD integer (no duplicates)
4. **Change Detection:** Identify updated vs new entities in future submissions
5. **Aggregate Focus:** Prioritize identity management for domain aggregate roots
6. **Offline Preparation:** Data providers can generate identifiers without API connectivity

---

## Goals & Scope

### Primary Goals

✅ **Stable External Identifiers:** Support UUID or natural key references from external systems  
✅ **Maintain Integer PKs:** Keep existing integer PKs for performance and compatibility  
✅ **Bidirectional Mapping:** Permanent ExternalID ↔ Integer mappings  
✅ **Idempotent Allocation:** Same external ID → Same integer (no duplicates)  
✅ **Change Detection Ready:** Foundation for future update detection capabilities  
✅ **Aggregate-Centric:** Focus on domain aggregate roots first

### Non-Goals

❌ **Replace Integer PKs:** Integers remain primary, external IDs are complementary  
❌ **Modify Existing Tables:** No changes to current PK columns (only add external ID columns)  
❌ **Natural Key Constraints:** Natural keys are external identifiers, not database constraints  
❌ **Automated Change Detection:** Phase 1 enables future detection, doesn't implement it

---

## Design Overview

### Three-Tier Identity Model

Each SEAD aggregate root will have:

```
┌─────────────────────────────────────────────────────────────┐
│ 1. INTEGER PRIMARY KEY (Internal - PostgreSQL Sequence)     │
│    • Generated by database at INSERT time                   │
│    • Used for internal SEAD operations, JOINs, FKs          │
│    • Optimized for performance (4 bytes vs 16 for UUID)     │
│    • Example: site_id, location_id, sample_id               │
└─────────────────────────────────────────────────────────────┘
                               ↕
┌─────────────────────────────────────────────────────────────┐
│ 2. EXTERNAL IDENTIFIER (User-Provided - UUID or Natural Key)│
│    • UUID: Generated by external system (shape_shifter)     │
│    • Natural Key: Composite business key from source data   │
│    • Used for idempotent ingestion and reconciliation       │
│    • Examples:                                               │
│      - site_uuid: "a3e4f567-e89b-12d3-..."                  │
│      - natural_key: "LAB_CODE|SITE_NAME|YEAR"               │
└─────────────────────────────────────────────────────────────┘
                               ↕
┌─────────────────────────────────────────────────────────────┐
│ 3. ALLOCATION MAPPING (Tracking Table)                      │
│    • Maps External ID → SEAD Integer PK                     │
│    • Tracks submission metadata (who, when, what)           │
│    • Enables audit trail and rollback                       │
│    • Stores content hash for future change detection        │
└─────────────────────────────────────────────────────────────┘
```

### External Identifier Types

#### Type 1: UUID (Preferred for New Systems)

**When to use:** Data providers with technical capability to generate UUIDs

```python
# External system (e.g., Shape Shifter)
site_uuid = uuid4()  # "a3e4f567-e89b-12d3-a456-426614174001"
```

**Advantages:**
- Globally unique (no collisions)
- Offline generation (no API calls needed)
- Non-sequential (security benefit)
- Standardized format

#### Type 2: Natural Key (Composite Business Key)

**When to use:** Legacy systems, Excel imports, data without UUID support

```python
# External system constructs natural key from business attributes
natural_key = f"{lab_code}|{site_name}|{collection_year}"
# "LAB_SWEDEN|Abisko_Site_A|2025"
```

**Advantages:**
- Human-readable and verifiable
- No code changes needed in legacy systems
- Leverages existing business rules
- Self-describing

**Requirements:**
- Must be stable (immutable attributes only)
- Must be unique within entity type
- Should be deterministic (same data → same key)
- Delimiter-separated components (e.g., `|` or `:`)

### Aggregate Roots

Focus identity management on **domain aggregate roots** - entities that are meaningful entry points and have dependents:

**Priority Aggregates (Phase 1):**
- **Location** (`tbl_locations`) - Geographic entities
- **Site** (`tbl_sites`) - Archaeological/sampling sites
- **Sample Group** (`tbl_sample_groups`) - Collection context
- **Physical Sample** (`tbl_physical_samples`) - Core analytical unit
- **Analysis Entity** (`tbl_analysis_entities`) - Measurement context

**Rationale:**
- Focus effort on high-value entities
- Dependent entities inherit parent references (via FK)
- Simpler change detection scope
- Gradual rollout to other tables

---

## Identity Allocation Workflow

### Step 1: External System Preparation

Data provider generates identifiers based on capability:

```python
# Option A: UUID capability
df["site_uuid"] = [str(uuid4()) for _ in range(len(df))]
external_id = site_uuid

# Option B: Natural key construction
df["natural_key"] = df.apply(
    lambda row: f"{row['lab_code']}|{row['site_name']}|{row['year']}", 
    axis=1
)
external_id = natural_key
```

### Step 2: Submission Creation

```http
POST /api/v1/identity/submissions
{
  "submission_name": "dendro_batch_2026_02",
  "source_system": "shape_shifter",
  "data_type": "dendro"
}

Response: { "submission_id": "123e4567-..." }
```

### Step 3: Batch Allocation (Idempotent)

```http
POST /api/v1/identity/submissions/{submission_id}/allocate
{
  "entity_type": "site",
  "allocations": [
    {
      "external_id": "a3e4f567-...",  // UUID
      "id_type": "uuid",
      "content_hash": "sha256:abc123..."  // For future change detection
    },
    {
      "external_id": "LAB_SE|Abisko_A|2025",  // Natural key
      "id_type": "natural_key",
      "content_hash": "sha256:def456..."
    }
  ]
}

Response: {
  "allocations": [
    { "external_id": "a3e4f567-...", "sead_id": 12345, "action": "allocated" },
    { "external_id": "LAB_SE|Abisko_A|2025", "sead_id": 12346, "action": "existing" }
  ]
}
```

**Idempotency:** Same external_id → Same sead_id (no new allocation)

### Step 4: Change Detection (Future Capability)

Content hash enables detection without full data comparison:

```python
# New submission with updated data
new_hash = hashlib.sha256(serialize(entity_data)).hexdigest()

# API compares stored hash vs new hash
if stored_hash != new_hash:
    action = "update"  # Generate UPDATE statement
else:
    action = "skip"    # No changes, skip SQL generation
```

**Phase 1:** Store hashes, don't use for detection yet  
**Phase 2:** Implement change detection in ingester

---

## API Design Principles

### Idempotency

All allocation operations are idempotent:
- Same external_id → Same sead_id
- Re-submitting unchanged data → No new allocations
- Concurrent submissions → Database-level uniqueness guarantees

### Flexibility

Support multiple identifier types:
- `id_type: "uuid"` - Standard UUID v4
- `id_type: "natural_key"` - Composite business key
- Future: `id_type: "doi"`, `id_type: "orcid"`, etc.

### Atomic Operations

Batch allocations are transactional:
- All allocations succeed, or all rollback
- No partial state
- Clean error recovery

### Stateless API

Each request contains full context:
- No sessions or cookies
- API key authentication
- Idempotent by design

---

## Data Model Concepts

### Allocation Record

```
AllocationRecord:
  submission_id: UUID
  entity_type: String          # "site", "sample", "location"
  external_id: String           # UUID or natural key
  id_type: Enum                 # "uuid" | "natural_key"
  sead_id: Integer              # Allocated SEAD PK
  content_hash: String          # SHA-256 of serialized entity
  allocation_time: Timestamp
  status: Enum                  # "allocated" | "committed" | "rolled_back"
```

### Submission

```
Submission:
  submission_id: UUID
  submission_name: String
  source_system: String
  data_type: String
  status: Enum                  # "pending" | "committed" | "rolled_back"
  created_at: Timestamp
```

### Entity Table Extension (Phase 1 Aggregates)

Existing tables augmented with external_id column:

```sql
-- Example: tbl_sites
ALTER TABLE tbl_sites ADD COLUMN site_external_id TEXT NULL;
CREATE UNIQUE INDEX idx_site_external_id ON tbl_sites(site_external_id) 
  WHERE site_external_id IS NOT NULL;
```

**Naming convention:** `{entity}_external_id`  
**Nullable:** Yes (backward compatibility during rollout)  
**Unique:** Yes (constraint ensures 1:1 mapping)

---

## Change Detection Strategy

### Phase 1: Foundation (Current Design)

Store content hashes without using them:

```python
# During allocation
content_hash = hashlib.sha256(
    json.dumps(entity_data, sort_keys=True).encode()
).hexdigest()

# Stored in allocation record for future use
```

### Phase 2: Detection Logic (Future Enhancement)

Ingester checks for changes:

```python
# Query existing allocations
existing = api.get_allocation(external_id)

if existing:
    if existing.content_hash == new_content_hash:
        action = "skip"  # No changes
    else:
        action = "update"  # Changed data
        sql_type = "UPDATE"
else:
    action = "insert"  # New entity
    sql_type = "INSERT"
```

### Phase 3: Granular Change Tracking (Future)

Track changes at column level (if needed):

```python
# Store column-level hashes (optional optimization)
column_hashes = {
    col: hashlib.md5(str(value).encode()).hexdigest()
    for col, value in entity_data.items()
}
```

**Design Decision:** Start simple (entity-level hash), optimize later if needed.

---

## Aggregate Root Strategy

### Aggregate Definition

An aggregate root is an entity that:
1. Has independent lifecycle (can exist without parent)
2. Has dependent child entities (composition relationship)
3. Enforces consistency boundaries
4. Is an ingestion entry point

### Identity Scope

**Phase 1 Aggregates:** External IDs required
- Location, Site, Sample Group, Physical Sample, Analysis Entity

**Dependent Entities:** No external IDs (inherit from aggregate)
- Measurements, attributes, relationships
- Referenced via parent's external ID + local keys
- Example: `measurement.sample_external_id + measurement.type`

### Benefits

1. **Focused Effort:** 5-10 aggregates instead of 100+ tables
2. **Clear Boundaries:** Change detection scoped to aggregates
3. **Simplified APIs:** Allocate IDs for aggregates only
4. **Easier Testing:** Smaller surface area
5. **Domain Alignment:** Matches how data providers think

---

## Implementation Phases

### Phase 1: Core Infrastructure (Weeks 1-4)
- Deploy allocation tracking tables
- Implement REST API (create submission, allocate, commit, rollback)
- Support UUID and natural key identifier types
- Add external_id columns to 5 priority aggregates
- Content hash storage (for future change detection)

**Deliverable:** Working identity allocation API

### Phase 2: Shape Shifter Integration (Weeks 5-8)
- UUID generation in ingester
- Natural key construction from business keys
- API client integration
- Idempotent SQL generation (INSERT ... ON CONFLICT)

**Deliverable:** Working ingester with identity allocation

### Phase 3: Pilot & Validation (Weeks 9-10)
- Test with 3-5 real datasets
- Validate UUID and natural key workflows
- Performance tuning
- Documentation

**Deliverable:** Production-ready system

### Phase 4: Remaining Aggregates (Weeks 11-12)
- Expand to remaining aggregate roots
- Backfill external IDs for existing data

**Deliverable:** Full aggregate coverage

### Phase 5: Change Detection (Future)
- Implement hash comparison logic
- Generate UPDATE vs INSERT SQL
- Column-level change tracking (if needed)

**Deliverable:** Change detection capability

---

## Design Decisions

### ✅ Decision 1: Hybrid Identifiers (UUID + Natural Keys)

**Rationale:** Not all data providers can generate UUIDs. Natural keys enable legacy system integration without code changes.

**Trade-off:** More complex validation (check format + uniqueness for each type), but gained flexibility.

### ✅ Decision 2: Keep Integer PKs

**Rationale:** External IDs are complementary, not replacements. Integer PKs remain for performance (4 bytes vs 16+ for UUID/natural key) and backward compatibility.

**Trade-off:** Dual identity adds complexity, but preserves existing ecosystem.

### ✅ Decision 3: Content Hash Storage (Phase 1)

**Rationale:** Store hashes now, use for change detection later. Avoids schema changes when adding detection logic.

**Trade-off:** Extra storage (~32 bytes/entity), but enables future capabilities.

### ✅ Decision 4: Aggregate-Centric Approach

**Rationale:** Focus on 5-10 key aggregates instead of 100+ tables. Aligns with domain model and reduces scope.

**Trade-off:** Dependent entities don't get external IDs directly, but inherit from parents.

### ✅ Decision 5: Entity-Level Hashing (Not Column-Level)

**Rationale:** Start simple. Entity-level hash is sufficient for most change detection needs. Column-level is premature optimization.

**Trade-off:** Can't detect which columns changed without re-parsing data, but simpler implementation.

---

## Open Questions

1. **Hash Algorithm:** SHA-256 (current) vs BLAKE3 (faster) vs MD5 (smallest)?
   - **Recommendation:** SHA-256 (standard, secure, good balance)

2. **Natural Key Delimiter:** Pipe `|` vs colon `:` vs hash `#`?
   - **Recommendation:** Pipe `|` (visible, not URL-encoded, not JSON-special)

3. **Natural Key Components:** Who defines them? SEAD team or data provider?
   - **Recommendation:** SEAD team defines per-entity-type rules, data provider follows

4. **Backfill Strategy:** How to assign external IDs to existing SEAD data?
   - **Recommendation:** Generate UUIDs server-side, store in allocation table, gradually add to entities

5. **Change Detection Granularity:** When do we need column-level change tracking?
   - **Recommendation:** Defer to Phase 5, evaluate based on real-world usage (YAGNI)

---

## Success Criteria

### Functional
- ✅ Allocate 10,000 external IDs in < 30 seconds (batch API)
- ✅ 100% idempotency (same external ID → same SEAD ID across runs)
- ✅ Support both UUID and natural key workflows
- ✅ Zero ID collisions in concurrent submissions
- ✅ Content hashes stored for all allocations

### Integration
- ✅ Shape Shifter successfully uses allocation API
- ✅ 3+ data providers successfully submit data (UUID and natural key workflows)
- ✅ Legacy Excel-based workflow supported via natural keys

### Foundation
- ✅ Content hash infrastructure ready for Phase 5 change detection
- ✅ All priority aggregates have external_id columns
- ✅ Allocation API supports future identifier types (DOI, ORCID, etc.)

---

## Future Enhancements

### Short-Term (Phase 2-4)
- Expand to all aggregate roots (beyond initial 5)
- Optimize batch allocation (parallel processing)
- Support additional identifier types (DOI, ORCID)

### Medium-Term (Phase 5)
- Change detection implementation (hash comparison)
- Generate UPDATE vs INSERT SQL
- Conflict resolution strategies

### Long-Term (Phase 6+)
- Column-level change tracking (if justified by usage)
- Semantic versioning for entities (v1, v2, v3...)
- Cross-SEAD instance federation (shared identifiers)
- Natural key federation (same key → different SEAD instances)

---

## Appendix A: Natural Key Examples

```yaml
# Natural key definitions (per entity type)

site:
  components: [lab_code, site_name, collection_year]
  delimiter: "|"
  example: "LAB_SWEDEN|Abisko_Site_A|2025"
  
location:
  components: [country_code, region, location_name]
  delimiter: "|"
  example: "SE|Norrbotten|Abisko"
  
physical_sample:
  components: [lab_code, sample_id, alt_ref]
  delimiter: "|"
  example: "LAB_SWEDEN|SAMPLE_001|REF_2025_A"
```

**Guidelines:**
- Use immutable attributes only (no dates that can change)
- Order components by specificity (broad → specific)
- Normalize values (uppercase, trim whitespace)
- Document component rules per entity type

---

## Appendix B: External Identifier Decision Tree

```
START: Data provider preparing submission
  │
  ├─ Can generate UUIDs?
  │  ├─ YES → Use UUID
  │  │       • Generate uuid4() for each entity
  │  │       • Store in external_id column
  │  │       • Submit to allocation API (id_type: "uuid")
  │  │
  │  └─ NO → Use natural key
  │          • Identify stable business key components
  │          • Construct: component1|component2|component3
  │          • Validate uniqueness within dataset
  │          • Submit to allocation API (id_type: "natural_key")
  │
  └─ API allocates SEAD integer PK
     └─ Returns: external_id → sead_id mapping
        └─ Ingester generates SQL with allocated IDs
```

---

## Appendix C: Content Hash Specification

**Algorithm:** SHA-256

**Input:** JSON-serialized entity data (deterministic ordering)

```python
import hashlib
import json

def compute_content_hash(entity_data: dict) -> str:
    """
    Computes content hash for change detection.
    
    - Excludes: internal IDs, timestamps, metadata
    - Includes: all domain data
    - Deterministic: sorted keys ensure same hash for same data
    """
    # Exclude internal/metadata fields
    excluded_fields = ["system_id", "created_at", "updated_at", "sead_id"]
    
    clean_data = {
        k: v for k, v in entity_data.items() 
        if k not in excluded_fields
    }
    
    # Deterministic serialization
    serialized = json.dumps(clean_data, sort_keys=True, ensure_ascii=True)
    
    # SHA-256 hash
    return hashlib.sha256(serialized.encode()).hexdigest()
```

**Storage:** Hex string (64 characters)

**Usage:** Compare stored vs new hash to detect changes

---

**End of Document**

**Related Documents:**
- [SEAD_IDENTITY_IMPLEMENTATION.md](./SEAD_IDENTITY_IMPLEMENTATION.md) - Database schema, API specification, SQL functions
- [SEAD_IDENTITY_NFR.md](./SEAD_IDENTITY_NFR.md) - Performance, security, testing, monitoring
- [SEAD_INGESTER_DESIGN.md](./SEAD_INGESTER_DESIGN.md) - Shape Shifter ingester integration

