"""Column introspection service for FK editor assistance.

Analyzes entity configurations to determine available columns without executing
the normalization pipeline. Provides column suggestions for FK editing.
"""

from typing import Optional

from loguru import logger
from pydantic import BaseModel

from backend.app.models.project import Project
from backend.app.services.project_service import ProjectService


class ColumnAvailability(BaseModel):
    """Available columns categorized by source."""

    explicit: list[str] = []  # From columns: [...]
    keys: list[str] = []  # From keys: [...]
    extra: list[str] = []  # From extra_columns: {...}
    unnested: list[str] = []  # Generated from unnest config
    foreign_key: list[str] = []  # Inherited FK columns from parents
    system: list[str] = []  # system_id, public_id
    directives: list[str] = []  # @value: paths


class ColumnIntrospectionService:
    """Service for analyzing entity configurations to determine available columns."""

    def __init__(self, project_service: ProjectService):
        self.project_service = project_service

    def get_available_columns(
        self, project_name: str, entity_name: str, remote_entity: Optional[str] = None
    ) -> dict[str, ColumnAvailability]:
        """
        Get available columns for FK editing.

        Args:
            project_name: Name of the project
            entity_name: Local entity (child in FK relationship)
            remote_entity: Optional remote entity (parent in FK relationship)

        Returns:
            Dict with 'local_columns' and optionally 'remote_columns'
        """
        project = self.project_service.load_project(project_name)

        result = {"local_columns": self._analyze_entity(project, entity_name)}

        if remote_entity:
            result["remote_columns"] = self._analyze_entity(project, remote_entity)

        return result

    def _analyze_entity(self, project: Project, entity_name: str) -> ColumnAvailability:
        """
        Analyze a single entity to determine available columns.

        Args:
            project: Project configuration
            entity_name: Entity to analyze

        Returns:
            ColumnAvailability with categorized columns
        """
        if entity_name not in project.entities:
            logger.warning(f"Entity {entity_name} not found in project")
            return ColumnAvailability()

        entity_config = project.entities[entity_name]
        availability = ColumnAvailability()

        # Explicit columns from 'columns' field
        if "columns" in entity_config and entity_config["columns"]:
            columns = entity_config["columns"]
            # Only convert to list if it's already a list (not a string directive)
            if isinstance(columns, list):
                availability.explicit = list(columns)
            elif isinstance(columns, str):
                # String directive - add to directives instead
                availability.directives.append(columns)

        # Business keys from 'keys' field
        if "keys" in entity_config and entity_config["keys"]:
            keys = entity_config["keys"]
            if isinstance(keys, list):
                availability.keys = list(keys)

        # Extra columns from 'extra_columns' dict
        if "extra_columns" in entity_config and entity_config["extra_columns"]:
            availability.extra = list(entity_config["extra_columns"].keys())

        # Unnested columns from 'unnest' configuration
        if "unnest" in entity_config and entity_config["unnest"]:
            availability.unnested = self._extract_unnest_columns(entity_config["unnest"])

        # Foreign key columns inherited from parent entities
        availability.foreign_key = self._extract_fk_columns(project, entity_name)

        # System columns (always available)
        availability.system = ["system_id"]
        if "public_id" in entity_config and entity_config["public_id"]:
            availability.system.append(entity_config["public_id"])

        # Generate @value directive suggestions and add to existing directives
        availability.directives.extend(self._generate_directive_options(entity_name))

        return availability

    def _extract_unnest_columns(self, unnest_config: dict) -> list[str]:
        """
        Extract column names that will be generated by unnesting.

        Args:
            unnest_config: Unnest configuration dict

        Returns:
            List of generated column names
        """
        columns = []

        # value_id column (if value_column specified)
        if "value_column" in unnest_config:
            columns.append("value_id")

        # value_name column (if value_column specified)
        if "value_column" in unnest_config:
            columns.append("value_name")

        # Variable name column (if var_name specified)
        if "var_name" in unnest_config and unnest_config["var_name"]:
            var_name = unnest_config["var_name"]
            if isinstance(var_name, str) and not var_name.startswith("@"):
                columns.append(var_name)

        # ID variables (if id_vars specified)
        if "id_vars" in unnest_config and unnest_config["id_vars"]:
            id_vars = unnest_config["id_vars"]
            # Only extend if it's a list, not a string directive
            if isinstance(id_vars, list):
                columns.extend(id_vars)

        # Value variables (if value_vars specified and not a directive)
        if "value_vars" in unnest_config and unnest_config["value_vars"]:
            value_vars = unnest_config["value_vars"]
            # Only extend if it's a list, not a string directive
            if isinstance(value_vars, list):
                columns.extend(value_vars)

        return columns

    def _extract_fk_columns(self, project: Project, entity_name: str) -> list[str]:
        """
        Extract FK column names inherited from parent entities.

        Args:
            project: Project configuration
            entity_name: Entity to analyze

        Returns:
            List of FK column names
        """
        fk_columns = []

        if entity_name not in project.entities:
            return fk_columns

        entity_config = project.entities[entity_name]

        # Check if entity has foreign_keys defined
        if "foreign_keys" not in entity_config or not entity_config["foreign_keys"]:
            return fk_columns

        # For each FK, the child gets a column named after parent's public_id
        for fk in entity_config["foreign_keys"]:
            if "entity" in fk and fk["entity"]:
                parent_entity = fk["entity"]
                if parent_entity in project.entities:
                    parent_config = project.entities[parent_entity]
                    if "public_id" in parent_config and parent_config["public_id"]:
                        fk_columns.append(parent_config["public_id"])

        return fk_columns

    def _generate_directive_options(self, entity_name: str) -> list[str]:
        """
        Generate @value directive suggestions for common patterns.

        Args:
            entity_name: Entity name for context

        Returns:
            List of @value directive strings
        """
        return [
            f"@value:entities.{entity_name}.keys",
            f"@value:entities.{entity_name}.columns",
        ]
